<!DOCTYPE html>

<html>
<head>
	
	<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
	<meta content="utf-8" http-equiv="encoding">
	
	<title>Art demo</title>
	
	<script src="http://cdnjs.cloudflare.com/ajax/libs/three.js/r73/three.min.js"></script>
	<script src="http://sdk.altvr.com/libs/altspace.js/0.14.1/altspace.min.js"></script>
	
	<style>
		.msg{
			
			font-size: 48px;
			padding: 30px;
			text-align: center;
			font-family: sans-serif;
			font-weight: bold;
		}
		#loading{
			background-color: #CC88FF;
		}
		#flatscreenError{
			background-color: #FF88CC;
			display: none;
		}
	</style>
	
</head>
<body>
	
	
	
	<div id="loading" class="msg">
		Loading...
	</div>
	<div id="flatscreenError" class="msg">
		Beam this app to a 3D enclosure!
	</div>
	
	
	<script>
	
	
	function fullPath(filename,withSearch){
		var curPath = location.pathname;
		if (!curPath.endsWith('/')) curPath = location.pathname.split('/').slice(0, -1).join('/') + '/';
		curPath = location.origin + curPath + filename;
		if (withSearch) curPath += location.search;
		return curPath;
	}
	
	
	
	var enclosureInfo,skeletonInfo,userInfo,popupInfo,firebaseInfo;
	
	
	function altspaceSetup(){
		
		
		altspace.getEnclosure().then(function(_enclosureInfo){
			enclosureInfo = _enclosureInfo;
			
			console.log("enclosure get");
			
			if (enclosureInfo.innerDepth == 1) {//if enclosure is flat
				
				altspace.getThreeJSRenderer().render(new THREE.Scene());//provide dummy 3D content so the beaming is possible
				console.log("flat render initiated...");
				
				setTimeout(function(){
					document.getElementById('loading').style.display = "none";
					document.getElementById('flatscreenError').style.display = "block";//ask to be beamed someplace 3D
					console.log("flat render safety delay complete.");
				},1000);
				
				return;//stop completely; successful beam will be a fresh load
				
			}
			
			
			
			function attemptContinue(){
				if (document.readyState == "complete") {
					
					console.log("READYSTATE MUST BE COMPLETE!");
					
					altspace.getThreeJSTrackingSkeleton().then(function(_skeletonInfo){
						skeletonInfo = _skeletonInfo;
						
						altspace.getUser().then(function(_userInfo){
							userInfo = _userInfo;
							
							altspace.open(
								fullPath('popup.html',true),
								'_experience',
								{ icon:fullPath('popup_icon.png',false), hidden:true }
							).then(function(_popupInfo){
								
								popupInfo = _popupInfo;
								
								altspace.utilities.sync.connect({
									authorId:'ravenworks',
									appId:'sculpTogether',
									baseRefUrl:"https://ravenworks-altspace-test.firebaseio.com"
								}).then(function(_firebaseInfo){
									firebaseInfo = _firebaseInfo;
									
									setTimeout(browserSetup,0);
									
								});
								
							});
							
						});
					});
					
				}
			}
			
			// both, right? in case it's already loaded? in which case the event will never go off anyway?
			document.onreadystatechange = attemptContinue;
			attemptContinue();
			
			
			
		});
		
		
		
		function quatDot(a,b) {
			return a.x*b.x + a.y*b.y + a.z*b.z + a.w*b.w;
		}
		function quatDist(a,b) {
			return (1-Math.abs(quatDot(a,b)));//should be *2 according to formula, but that gives answers from 0-2, and I'd rather 0-1 anyway?
		}
		
		
		
		function browserSetup(){
			
			
			
			var renderer = altspace.getThreeJSRenderer();
			var scene = new THREE.Scene();
			
			
			
			
			var ribbonCanvas = document.createElement('canvas');
			ribbonCanvas.width = ribbonCanvas.height = 8;
			var ribbonCtx = ribbonCanvas.getContext('2d');
			var ribbonGrad = ribbonCtx.createLinearGradient(0,0,0,ribbonCanvas.height);
			ribbonGrad.addColorStop(1,"#FFF");
			ribbonGrad.addColorStop(0,"#AAA");
			ribbonCtx.fillStyle = ribbonGrad;
			ribbonCtx.fillRect(0,0,8,8);
			
			var cubeCanvas = document.createElement('canvas');
			cubeCanvas.width = cubeCanvas.height = 16;
			var cubeCtx = cubeCanvas.getContext('2d');
			cubeCtx.fillStyle = "#00F";
			cubeCtx.fillRect(0,0,cubeCanvas.width,cubeCanvas.height);
			var cubeGrad = cubeCtx.createLinearGradient(0,0,0,cubeCanvas.height);
			cubeGrad.addColorStop(0,"rgba(255,255,255,0.0)");
			cubeGrad.addColorStop(1,"rgba(255,255,255,0.8)");
			cubeCtx.fillStyle = cubeGrad;
			cubeCtx.fillRect(0,0,cubeCanvas.width,cubeCanvas.height);
			var sphereMat = new THREE.MeshBasicMaterial({map:new THREE.Texture(cubeCanvas)});
			
			
			
			var primGeoms = [
				new THREE.SphereGeometry(0.5,16,16),
				new THREE.BoxGeometry(1,1,1)
			];
			var primMats = [
				sphereMat,
				sphereMat//whatever for now
			];
			
			
			
			function applyTransformFromArray(obj,transList){
				obj.position.set(transList[0],transList[1],transList[2]);
				obj.rotation.set(transList[3],transList[4],transList[5]);
				obj.scale.set(transList[6],transList[7],transList[8]);
			}
			
			
			
			var syncInstance = firebaseInfo.instance;
			
			var artServer = syncInstance.child('art');
			var usersServer = artServer.child('users');
			usersServer.on("child_added",function(snapshot,prevChildKey){
				
				
				snapshot.ref().child("strokes").on("child_added",function(snapshot,prevChildKey){
					
					
					var curStrokeInfo = snapshot.val();
					
					var ribbonMat = new THREE.MeshBasicMaterial({
						map:new THREE.Texture(ribbonCanvas),
						color:new THREE.Color(curStrokeInfo.color)
					});
					ribbonMat.side = THREE.DoubleSide;
					
					
					var lastPointKey = null;
					var lastPointInfo = null;
					snapshot.ref().child("points").on("child_added",function(snapshot,prevChildKey){
						
						var curPointInfo = snapshot.val();
						
						if (lastPointKey) {
							
							if (prevChildKey != lastPointKey) console.log("on strokes: LAST CHILD KEY MISMATCH?????");
							
							var newGeom = new THREE.Geometry();
							newGeom.vertices.push(
								lastPointInfo.vertices[0], lastPointInfo.vertices[1],
								curPointInfo.vertices[0], curPointInfo.vertices[1]
							);
							newGeom.faces.push( new THREE.Face3(0,1,2), new THREE.Face3(2,1,3) );
							newGeom.faceVertexUvs = [[
								[new THREE.Vector2(0,0),new THREE.Vector2(0,1),new THREE.Vector2(1,0)],
								[new THREE.Vector2(1,0),new THREE.Vector2(0,1),new THREE.Vector2(1,1)]
							]];
							newGeom.computeVertexNormals();
							
							
							
							var newMesh = new THREE.Mesh( newGeom, ribbonMat );
							scene.add(newMesh);
							
						}
						
						lastPointKey = snapshot.key();
						lastPointInfo = curPointInfo;
						
					});
					
					snapshot.ref().child("deletions").on("child_added",function(snapshot,prevChildKey){
						
					});
					
					
				});
				
				
				
				
				var myPrimsList = {};
				
				snapshot.ref().child("prims").on("child_added",function(snapshot,prevChildKey){
					
					var primSource = snapshot.val();
					
					var newPrimInfo = {};
					
					var primMesh = new THREE.Mesh( primGeoms[primSource.typeIndex], primMats[primSource.typeIndex] );
					applyTransformFromArray(primMesh,primSource.transform);
					scene.add(primMesh);
					newPrimInfo.mesh = primMesh;
					
					myPrimsList[snapshot.key()] = newPrimInfo;
					
				});
				snapshot.ref().child("prims").on("child_changed",function(snapshot,prevChildKey){
					
					applyTransformFromArray(myPrimsList[snapshot.key()].mesh,snapshot.val().transform);
					
				});
				snapshot.ref().child("prims").on("child_removed",function(deadSnapshot){
					
					var key = deadSnapshot.key();
					scene.remove(myPrimsList[key].mesh);
					delete myPrimsList[key];
					
				});
				
				
				
				
			});
			
			
			
			
			
			
			var ppm = enclosureInfo.pixelsPerMeter;
			console.log("ENCLOSURE SCALE:",ppm);
			
			
			function toWorldUnits(x){
				return x*ppm /17.873589;//hardcoded divisor; numbers were tuned to that room's ppm
			}
			
			
			function isFingerPointing(fingerName,handName){
				
				var baseJoint = skeletonInfo.getJoint(fingerName,handName,0);
				var firstJoint = skeletonInfo.getJoint(fingerName,handName,3);
				
				var bendAmt = quatDist(baseJoint.quaternion,firstJoint.quaternion);
				
				return (bendAmt < 0.03);
				
			}
			
			function offPtInDir(pt,dir,dist){
				var off = new THREE.Vector3(0,0,dist);
				off.applyQuaternion(dir);
				off.add(pt);
				return off;
			}
			function getFingertipPos(fingerName,handName,posOut,quatOut){
				
				var lastJointIndex = 3;//check if this needs to be changed for thumb, presumably?
				
				
				// finger joints aren't NECESSARILY the same length but it's the right ballpark
				
				var midJoint = skeletonInfo.getJoint(fingerName,handName,lastJointIndex-1);
				var lastJoint = skeletonInfo.getJoint(fingerName,handName,lastJointIndex);
				
				var jointLength = midJoint.position.distanceTo(lastJoint.position);
				
				posOut.copy(offPtInDir(lastJoint.position,lastJoint.quaternion,jointLength));
				quatOut.copy(lastJoint.quaternion);
				
			}
			
			
			
			var pinchDebugGeom = new THREE.SphereGeometry(0.2);
			var pinchDebugMat = new THREE.MeshBasicMaterial({color:0xFF00FF});
			var pinchDebugMeshes = {
				'Left':new THREE.Mesh(pinchDebugGeom,pinchDebugMat),
				'Right':new THREE.Mesh(pinchDebugGeom,pinchDebugMat)
			}
			
			//scene.add(pinchDebugMeshes['Left']);
			//scene.add(pinchDebugMeshes['Right']);
			
			
			function getHandPinch(handName,threshhold){
				
				var indexPos = new THREE.Vector3();
				var thumbPos = new THREE.Vector3();
				var dummyQuat = new THREE.Quaternion();
				
				getFingertipPos('Index',handName,indexPos,dummyQuat);
				getFingertipPos('Thumb',handName,thumbPos,dummyQuat);
				
				var pinchGap = indexPos.distanceTo(thumbPos);
				
				if (pinchGap < toWorldUnits(threshhold)) {
					
					
					//return new THREE.Vector3(
					//	(indexPos.x+thumbPos.x)/2,
					//	(indexPos.y+thumbPos.y)/2,
					//	(indexPos.z+thumbPos.z)/2
					//);
					
					// turns out that opening your fingers moves your index farther than your thumb,
					// so to avoid drift when releasing, let's assume pinches are a fixed point away from your palm
					
					var palmJoint = skeletonInfo.getJoint('Hand',handName,0);
					var pinchPoint = new THREE.Vector3(
						toWorldUnits(0.5),
						toWorldUnits(-1),
						toWorldUnits(1.5)
					);
					if (handName == "Left") pinchPoint.x *= -1;
					pinchPoint.applyQuaternion(palmJoint.quaternion);
					pinchPoint.add(palmJoint.position);
					
					pinchDebugMeshes[handName].position.copy(pinchPoint);
					
					return pinchPoint;
					
				} else {
					return false;
				}
				
			}
			
			
			
			
			
			var myDrawingServer = usersServer.child(userInfo.userId);
			var myStrokesServer = myDrawingServer.child('strokes');
			var myPrimsServer = myDrawingServer.child('prims');
			
			var curPointsServer = null;
			var lastPos = null;
			
			var cubeInProgress = null;
			
			var nextColVal = {h:0,s:0,l:0};//should be overwritten by firebase almost immediately, but at least it won't crash if not
			myDrawingServer.child("nextCol").on("value",function(snapshot){
				
				var newVal = snapshot.val();
				console.log("NEW COLOR VAL CHOICE:",newVal);
				if (!newVal) return;
				
				nextColVal = newVal;
				
			});
			
			
			
			
			function frameFunc() {
				
				requestAnimationFrame(frameFunc);
				
				
				if (skeletonInfo.getJoint('Hand','Right')) {
					
					
					if (isFingerPointing('Index','Right') && !isFingerPointing('Ring','Right')) {
						
						if (!curPointsServer) {
							
							var curStrokeServer = myStrokesServer.push({color:nextColVal});
							curPointsServer = curStrokeServer.child('points');
							
						}
						
						var fingerPos = new THREE.Vector3();
						var fingerQuat = new THREE.Quaternion();
						getFingertipPos('Index','Right',fingerPos,fingerQuat);
						
						if ( !lastPos || (fingerPos.distanceTo(lastPos) > toWorldUnits(0.1)) ) {
							
							var otherPos = offPtInDir(fingerPos,fingerQuat,toWorldUnits(0.5));
							
							var newPoint = curPointsServer.push();
							newPoint.set({vertices:[fingerPos,otherPos]});
							
						}
						
						lastPos = fingerPos;
						
					} else {
						
						curPointsServer = null;
						
					}
					
					
					
					if (skeletonInfo.getJoint('Hand','Left')) {
						
						
						var pinchThreshhold = cubeInProgress ? 1 : 1;//looser threshhold for release than for start, maybe?
						var rightPinch = getHandPinch('Right',pinchThreshhold);
						var leftPinch = getHandPinch('Left',pinchThreshhold);
						
						if (rightPinch && leftPinch) {
							
							var pinchSpace = rightPinch.distanceTo(leftPinch);
							
							var dataToUpdate = {};
							
							if (!cubeInProgress && (pinchSpace < toWorldUnits(1))) {
								
								cubeInProgress = myPrimsServer.push();
								dataToUpdate.typeIndex = 0;//hardcoded for now
								
							}
							
							if (cubeInProgress) {
								
								dataToUpdate.transform = [
									// position:
									(rightPinch.x + leftPinch.x)/2,
									(rightPinch.y + leftPinch.y)/2,
									(rightPinch.z + leftPinch.z)/2,
									// rotation:
									0,0,0,
									//scale:
									pinchSpace,pinchSpace,pinchSpace
								];
								
								cubeInProgress.update(dataToUpdate);
								
							}
							
						} else {
							
							if (cubeInProgress) {
								cubeInProgress = null;
							}
							
						}
						
						
						
						
					}
					
					
				}
				
				renderer.render(scene);
				
			}
			
			frameFunc();
			
			document.getElementById('loading').style.display = "none";
			
		}
		
		
	}
	
	altspaceSetup();
	
	
	</script>
	
	
	
</body>
</html>