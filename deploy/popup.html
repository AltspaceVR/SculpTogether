<html>
<head>
	
	<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
	<meta content="utf-8" http-equiv="encoding">
	
	<title>Sculpting Palette</title>
	
	<script src="http://cdnjs.cloudflare.com/ajax/libs/three.js/r73/three.min.js"></script>
	<script src="http://sdk.altvr.com/libs/altspace.js/0.14.1/altspace.min.js"></script>
	
	
	
	<script src="controls_leapmotion.js"></script>
	<script src="controls_cursor.js"></script>
	
	
	<style>
		body{
			background-color: #444;
			font-family: sans-serif;
		}
		
		
		#enable{
			background-color: #F8F;
			display: inline-block;
		}
		
		
		#title{
			text-align: center;
			font-size: 48px;
			background-color: #888;
		}
		
		.sectionHeader{
			text-align: center;
			background-color:#666;
			padding:10px 0;
			margin:4px 0;
		}
		
		
		.colSlider{
			width:48px;
			height:400px;
			display: inline-block;
			background-color: #000;
			position: relative;
			margin: 4px;
		}
		.colSliderInnerGrad{
			width: 100%;
			height: 100%;
			position: absolute;
		}
		#hueSliderGrad{
			background: linear-gradient(to bottom,
				hsl(0,  100%,50%),
				hsl(30, 100%,50%),
				hsl(60, 100%,50%),
				hsl(90, 100%,50%),
				hsl(120,100%,50%),
				hsl(150,100%,50%),
				hsl(180,100%,50%),
				hsl(210,100%,50%),
				hsl(240,100%,50%),
				hsl(270,100%,50%),
				hsl(300,100%,50%),
				hsl(330,100%,50%),
				hsl(360,100%,50%)
			);
		}
		#satSliderGradFront{
			background: linear-gradient(to bottom,
				rgba(127,127,127,0),
				rgba(127,127,127,1)
			);
		}
		#satSliderGradBack{
			background-color: #0F0;
		}
		#litSliderGradFront{
			background: linear-gradient(to bottom,
				rgba(255,255,255,1),
				rgba(255,255,255,0) 50%,
				rgba(0,0,0,0) 50%,
				rgba(0,0,0,1)
			);
		}
		#litSliderGradBack{
			background-color: #00F;
		}
		
		.colSliderMarker{
			position: absolute;
			height: 2px;
			width: 100%;
			
			box-shadow: 0 0 0 2px rgba(0,0,0,1), 0 0 0 4px rgba(256,256,256,1), 0 0 0 6px rgba(0,0,0,1);
		}
		
		#colResult{
			background-color: #F0F;
			height: 40px;
		}
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		.radioOption{
			text-align: center;
			padding: 20px 0;
			margin: 4px 0;
			font-weight: bold;
		}
		.roSelected{
			background-color:#FAC;
		}
		.roUnselected{
			background-color:#AAA;
		}
		
	</style>
</head>
<body>
	<div id="title">SculpTogether Palette</div>
	<div id="modeDisplay">cursor mode</div>
	<div id="enable">Enable cursor drawing</div>
	<table id="controls"><tr>
		<td>
			<div class="sectionHeader">Select color:</div>
			<div id="hueSlider" class="colSlider">
				<div class="colSliderInnerGrad" id="hueSliderGrad">&nbsp;</div>
				<div class="colSliderMarker" id="hueMarker"></div>
			</div>
			<div id="satSlider" class="colSlider">
				<div class="colSliderInnerGrad" id="satSliderGradBack">&nbsp;</div>
				<div class="colSliderInnerGrad" id="satSliderGradFront">&nbsp;</div>
				<div class="colSliderMarker" id="satMarker"></div>
			</div>
			<div id="litSlider" class="colSlider">
				<div class="colSliderInnerGrad" id="litSliderGradBack">&nbsp;</div>
				<div class="colSliderInnerGrad" id="litSliderGradFront">&nbsp;</div>
				<div class="colSliderMarker" id="litMarker"></div>
			</div>
			<div id="colResult">&nbsp;</div>
		</td>
		<td>
			<div class="sectionHeader">Stroke thickness:</div>
			<input type="range" id="thicknessSlider" min="0" max="1" step="0.01"/>
		</td>
		<td>
			<div class="sectionHeader">Pinch creates:</div>
			<div id="shapeOptionsHolder"></div>
		</td>
		<td>
			<div class="sectionHeader">Editing mode:</div>
			<div id="editOptionsHolder"></div>
		</td>
		<td>
			<div class="sectionHeader">Handedness:</div>
			<div id="handOptionsHolder"></div>
		</td>
		<td>
			<div class="sectionHeader">Room clear:</div>
			<button id="manualResetButton">Reset Now</button>
			<div id="previousResetInfo"></div>
			<div id="resetTimerDiv">...</div>
		</td>
	</tr></table>
	
	<script>
		
		
		var scene;//LEAVE EMPTY! the control scripts test for it, but it has to be declared
		
		
		function padTimeVal(num){
			var floorNum = Math.floor(num);
			return (floorNum<10 ? "0" : "") + floorNum;
		}
		function formatTime(milis){
			if (milis < 0) milis = 0;//at least in this situation?
			var secs = milis/1000;
			var secsStr = padTimeVal(secs%60);
			var mins = secs/60;
			var minsStr = padTimeVal(mins);
			return minsStr+":"+secsStr;
		}
		
		
		
		
		var now = new Date();
		console.log("start time",now.getHours()+":"+now.getMinutes()+":"+now.getSeconds());
		
		
		var skeletonInfo, userInfo, firebaseInfo;
		
		altspace.getThreeJSTrackingSkeleton().then(function(_skeletonInfo){
			skeletonInfo = _skeletonInfo;
			
			altspace.getUser().then(function(_userInfo){
				userInfo = _userInfo;
				
				altspace.utilities.sync.connect({
					authorId:'ravenworks',
					appId:'sculpTogether',
					baseRefUrl:"https://ravenworks-altspace-test.firebaseio.com"
				}).then(function(_firebaseInfo){
					firebaseInfo = _firebaseInfo;
					
					setTimeout(browserSetup,0);
					
				});
				
			});
			
		});
		
		
		
		
		var modeDisplayDiv = document.getElementById('modeDisplay');
		var enableButton = document.getElementById('enable');
		var controlsDiv = document.getElementById('controls');
		
		var editModeOptionInfo;
		
		var controlSystems = {
			leapmotion: SETUP_leapmotion(),
			cursor: SETUP_cursor()
		};
		
		var curControlSystem = controlSystems.cursor;//only safe assumption
		
		function changeControlSystem(newControlSystem){
			
			switch(curControlSystem){
				case controlSystems.cursor:
					enableButton.visibility = "hidden";
					controlsDiv.visibility = "visible";
				break;
			}
			
			curControlSystem = newControlSystem;
			
			switch(curControlSystem){
				case controlSystems.leapmotion:
					modeDisplayDiv.innerHTML = "leap motion mode";
					
					editModeOptionInfo.myOptions[1].style.display = "none";
					if (editModeOptionInfo.getCurVal() == 1) editModeOptionInfo.optionNumClick(0);//switch from "prim" to "draw+prim"
					
				break;
				
			}
			
		}
		
		function detectControlSystemMode(){
			
			if (curControlSystem != controlSystems.leapmotion){//always leapmotion if possible, so, no reason to keep searching then
				
				if (controlSystems.leapmotion.isAvailable()) {
					changeControlSystem(controlSystems.leapmotion);
				}
				
			}
			
			
		}
		
		
		
		
		function browserSetup(){
			
			
			
			var syncInstance = firebaseInfo.instance;
			
			
			
			
			function getAvg(test,then){
				
				var vals = [];
				
				function testPass(){
					test(testOver);
				}
				function testOver(newVal){
					vals.push(newVal);
					console.log(newVal);
					if (vals.length < 10) {
						testPass();
					} else {
						// discard outliers, maybe? although this is already so approximated it's probably not worth it
						var sum = 0;
						for(var i=0; i<vals.length; i++) sum += vals[i];
						var avg = sum/vals.length;
						console.log("avg:",avg);
						then(avg);
					}
				}
				
				testPass();
				
			}
			
			var myTimestampScratchpad = syncInstance.child("timestampScratchpad/"+Math.floor(Math.random()*1000000));
			function testClockSkew(returnTo){
				
				myTimestampScratchpad.set( Firebase.ServerValue.TIMESTAMP, function(e){
					myTimestampScratchpad.once('value',function(snapshot){
						
						var response = snapshot.val();
						var curClockSkew = performance.now()-response;//does NOT account for ping, but for these purposes, whatever
						
						returnTo(curClockSkew);
						
					});
				});
				
			}
			console.log("FIREBASE CLOCK SKEW:");
			getAvg(testClockSkew,clockSkewComplete);
			
			
			
			function clockSkewComplete(clockSkewResult){
				
				var timerDiv = document.getElementById("resetTimerDiv");
				
				var maxSessionMins = 30;
				var maxSessionMilis = maxSessionMins*60*1000;
				
				setInterval(function(){
					
					if (walkingDead) return;
					
					var milisSinceReset = performance.now()-lastWipeTime;
					milisSinceReset -= clockSkewResult;
					
					var milisLeft = (maxSessionMilis-milisSinceReset);
					
					timerDiv.innerHTML = "Seconds until next reset: "+formatTime(milisLeft);
					
					if (milisLeft <= 0) resetRoom(false);
					
				},1000);
				
			}
			
			
			
			
			
			
			var artServer = syncInstance.child('art');
			var allUsersServer = artServer.child('users');
			var myUserServer = allUsersServer.child(userInfo.userId);
			
			
			var isPopup = true;//this is a bit of a silly way to reuse this code, but I'll go with it for now...
			var previousWipeNum;
			var lastWipeTime;
			var wipeInfoServer = artServer.child('wipeInfo');
			wipeInfoServer.on('value',function(snapshot){
				
				var newWipeInfo = snapshot.val();
				if (!newWipeInfo) {
					console.log("no existing wipe info, this seems to be a new room! Resetting it now, to generate a lastWipeTime...");
					previousWipeNum = 1;
					resetRoom(false);//there might be a few people who all reset around the same time, but it shouldn't matter
					return;
				}
				var newWipeNum = newWipeInfo.num;
				console.log("current wipenum val:",newWipeNum);
				
				if (previousWipeNum) {
					console.log("previous wipenum val:",previousWipeNum);
					if (newWipeNum != previousWipeNum) {
						console.log("so, time to reload. (You probably can't see this log.)");
						if (walkingDead) {
							console.log("EXCEPT, I'm the one who sent the message, so I'm not going to until I hear back from the server!!");
						} else {
							location.reload();
						}
					} else {
						console.log("so, no reloading just yet.");
					}
				} else {
					console.log("this is the first wipenum I've seen, so I'll remember it.");
					previousWipeNum = newWipeNum;
					
					if (isPopup){
						var resetMsg = "Last reset was "+(newWipeInfo.wasManual?("manually by "+newWipeInfo.user):"by timer.");
						document.getElementById('previousResetInfo').innerHTML = resetMsg;
						lastWipeTime = newWipeInfo.time;
					}
				}
				
			});
			
			var walkingDead = false;
			
			function resetRoom(manual){
				
				walkingDead = true;
				
				artServer.set({wipeInfo:{
					num:(previousWipeNum+1),
					time:Firebase.ServerValue.TIMESTAMP,
					user:userInfo.displayName,
					wasManual:manual
				}},function(error){
					//news of reset has reached server, so:
					location.reload();
				});
				
			}
			// don't forget this is all in index, too
			
			
			document.getElementById('manualResetButton').addEventListener('click',function(){resetRoom(true)});
			
			
			
			// on load, painting mode will ALWAYS be 'cursor' until established otherwise
			
			var myEnableServer = myUserServer.child('enable');
			
			var enabled = false;
			controlsDiv.style.visibility = "hidden";
			
			enableButton.addEventListener('click',function(){
				enabled = !enabled;
				enableButton.innerHTML = (enabled?"dis":"en")+"able cursor drawing";
				controlsDiv.style.visibility = enabled?"visible":"hidden";
				myEnableServer.set(enabled);
			});
			
			
			
			
			var myNextColServer = myUserServer.child('nextCol');
			
			function setUpSlider(id,defaultVal){
				
				var sliderDiv = document.getElementById(id+"Slider");
				var sliderDisp = document.getElementById(id+"Marker");
				
				var sliderMax = sliderDiv.clientHeight;
				
				var fracVal;
				function newFracVal(newY){
					fracVal = newY/sliderMax;
					sliderDisp.style.top = newY-1;
				}
				newFracVal(defaultVal*sliderMax);
				
				sliderDiv.addEventListener('mousedown',function(e){
					
					var oldY = -99999;
					
					function moveFunc(e){
						var newY = e.pageY-sliderDiv.offsetTop;
						newY = Math.max(0,newY);
						newY = Math.min(newY,sliderMax);
						if (newY == oldY) return;
						
						newFracVal(newY);
						refreshColDisplay(false);
						
						oldY = newY;
					}
					function releaseFunc(e){
						document.body.removeEventListener('mousemove',moveFunc);
						document.body.removeEventListener('mouseup',releaseFunc);
						refreshColDisplay(true);
					}
					
					moveFunc(e);
					document.body.addEventListener('mousemove',moveFunc);
					document.body.addEventListener('mouseup',releaseFunc);
					
				});
				
				var info = {};
				info.getVal = function(){
					return fracVal;
				}
				
				return info;
				
			}
			var sliderH = setUpSlider("hue",Math.random());
			var sliderS = setUpSlider("sat",0);
			var sliderL = setUpSlider("lit",0.5);
			
			var sDisp = document.getElementById("satSliderGradBack");
			var lDisp = document.getElementById("litSliderGradBack");
			var cDisp = document.getElementById("colResult");
			function refreshColDisplay(tellServer){
				
				var h = sliderH.getVal();
				var s = sliderS.getVal();
				var l = sliderL.getVal();
				
				sDisp.style.backgroundColor = "hsl("+(h*360)+",100%,50%)";
				lDisp.style.backgroundColor = "hsl("+(h*360)+","+((1-s)*100)+"%,50%)";
				cDisp.style.backgroundColor = "hsl("+(h*360)+","+((1-s)*100)+"%,"+((1-l)*100)+"%)";
				
				if (tellServer) {
					var newColVal = cDisp.style.backgroundColor;
					console.log("sending new color choice val of",newColVal);
					myNextColServer.set(newColVal);
				}
				
			}
			refreshColDisplay(true);
			
			
			
			var strokeThicknessFracServer = myUserServer.child('strokeThicknessFrac');
			var thicknessControl = document.getElementById('thicknessSlider');
			function submitThickness(){
				strokeThicknessFracServer.set(thicknessControl.value);
			}
			thicknessControl.addEventListener('change',submitThickness);
			thicknessControl.value = 1/3;
			submitThickness();
			
			
			
			
			function makeRadioSet(serverId,divId,labelsList){
				
				var myOptionServer = myUserServer.child(serverId);
				
				var myOptionsHolderDiv = document.getElementById(divId);
				var myOptions = [];
				function makeOption(name){
					
					var myIndex = myOptions.length;
					
					var optionDiv = document.createElement('div');
					myOptionsHolderDiv.appendChild(optionDiv);
					optionDiv.innerHTML = name;
					
					optionDiv.addEventListener('click',function(){
						optionNumClick(myIndex);
					});
					
					myOptions.push(optionDiv);
					
				}
				for(var i=0; i<labelsList.length; i++) makeOption(labelsList[i]);
				
				var curOptionChoice;
				function optionNumClick(clickedIndex){
					for(var i=0; i<myOptions.length; i++){
						myOptions[i].className = "radioOption "+((i==clickedIndex)?"roSelected":"roUnselected");
					}
					curOptionChoice = clickedIndex;
					myOptionServer.set(clickedIndex);
				}
				optionNumClick(0);
				
				return {
					optionNumClick:optionNumClick,
					myOptions:myOptions,
					getCurVal:function(){return curOptionChoice;}
				};
				
			}
			
			makeRadioSet('nextShape','shapeOptionsHolder',['ball','cube']);
			editModeOptionInfo = makeRadioSet('editMode','editOptionsHolder',['draw','prim','erase']);
			makeRadioSet('handChoice','handOptionsHolder',['right','left']);
			
			
			
			
			function frameFunc(){
				requestAnimationFrame(frameFunc);
				detectControlSystemMode();
			}
			frameFunc();
			
			
		}
		
	</script>
	
</body>
</html>